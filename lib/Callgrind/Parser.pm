package Callgrind::Parser;
use strict;
use warnings;
use Carp;

# ABSTRACT: Parses Callgrind output file into a hashref representing the call tree of the source program

=head1 SYNOPSIS

The parser was designed to read Callgrind profile data as described L<http://kcachegrind.sourceforge.net/html/CallgrindFormat.html|here>.
Primarily written to read and manipulate profiling output generated by L<http://xdebug.org/|xdebug>.  Thus far it has only been tested
with files generated by xdebug.

=cut

=method parseFile

This method does all the work of the function.  Takes in the full path to a file to parse
Returns a hash containing the metadata read from the file header, as well has a hash ref
which represents the full call tree of the program from which the profile was generated.

=cut

sub parseFile {
    my($inf) = @_;
    
    open(my $fh, '<', $inf) or croak "Couldn't open input file for reading: $!\n";
    my(%meta)=();
    while (my $line = <$fh>) {
	chomp $line;
	next if(length($line) == 0);
	my($key, $value) = split(/:\s+/, $line);
	if ($key eq 'positions') {
	    $meta{$key} = [split(/\s+/, $value)];
	}
	elsif($key eq 'events') {
	    $meta{$key} = [split(/\s+/, $value)];
	    # discard trailing empty line
	    scalar(<$fh>);
	    last;
	}
	else {
	    $meta{$key} = $value;
	}
    }
    
    my(@buffer) = ();
    my(%commands) = ();
    while (my $line = <$fh>) {
	chomp $line;
	if (length($line) == 0){ 
	    # Handle summary line for program main
	    if ($buffer[-1] eq 'fn={main}') {
		my $summary =<$fh>;
		$summary=~m/(\d+)/;
		$meta{total_time} = $1;
		my $j = <$fh>;
	    }else{
		&_parseCommand(\@buffer, \%commands, \%meta);
		@buffer=();
	    }
	}
	else {
	    push @buffer, $line;
	}
    }
    close($fh);
    
    return {meta=>\%meta, main=>$commands{'{main}'}{instances}[0]};
}

sub _parseCommand {
    my($stack, $commands, $meta) = @_;
    # disregard file name
    shift @$stack;
    my $function = substr(shift @$stack, 3);
    
    my($line, @fields) = split(/\s+/, shift @$stack);
    
    $commands->{ $function } ||= {instances=>[]};
    my(%instance) = (line=>$line, function=>$function);
    @instance{ @{ $meta->{events} } } = @fields;
    while ($#$stack > 0) {
	# disregard file name
	shift @$stack;
	my $sfn = substr(shift @$stack, 4);
	my $ca  = substr(shift @$stack, 6);
	my($cline, $time) = split(/\s+/, shift @$stack);
	my $inst = shift @{ $commands->{ $sfn }{instances} };
	$inst->{called_from} = $cline;
	$inst->{time_inclusive} = $time;
	push @{ $instance{children} }, $inst;
    }
    push @{ $commands->{$function}{instances} }, \%instance;
}

1;
